목적 : 소켓 서버/클라이언트 제작하여 OS이론, 소켓통신, 그외TIP 이해, C/C++실력향상.
방식 : 요구사항에 맞게끔만 심플하게 제작후 컨펌. 그리고 다시 수정

1. TCP 소켓서버/클라이언트 제작(1)
 1.1 서버 동작방식
 - TCP/IP 프로토콜 사용.
 - 포트는 9000번 사용.
 - 콘솔로 개발.
 - 스레드 3개로 동작.
   ㄴ주스레드 : 소켓초기화 / 패킷data_check하는 스레드1개 생성 / 클라이언트 연결요청마다 recv스레드 1개생성
   ㄴrecv스레드 : 클라이언트 패킷받고, 큐에 삽입
   ㄴdata_check스레드 : 큐에있는 패킷을 pop하여 패킷시퀀스 태우기.
 - 서버와 클라는 패킷 주소받을시 패킷헤더+length 추가하여 서버와 클라간에 데이터를 제대로 파씽할수 있게끔한다.

 ex) 클라이언트 연결요청시
    (1) 해당 클라이언트만의 소켓생성하고, 해당소켓에 대한 recv스레드 1개 생성.

 ex) 클라이언트에게 채팅패킷을 받을시. 
    (1) 해당 클라이언트 recv스레드에서 recv()호출후 큐에 삽입.
    (2) data_check스레드에서 큐데이터를 빼와서 어떤 패킷인지(패킷타입확인) 확인후. szID|szMsg 빼오기

 1.2 클라이언트 동작방식
 - TCP/IP 프로토콜 사용.
 - szID | szMsg 타이핑후 엔터치면 서버로 전송.

 1.3 공통
 - 개발도구 : 비쥬얼스튜디오
 - 개발언어 : C/C++

----------------------------------------------------------------------------------------------------------------
위 서버의 문제점
(1) 클라이언트 소켓마다 쓰레드 하나를 생성하고 있음.
    클라이언트가 1000명 접속하면 쓰레드는 1000개 생성해야함.

    - 쓰레드가 많아지면 문제점은?
	컨텍스트스위칭이 발생해서 cpu에 과부하발생 속도 느려짐


(2) 초기에 소켓은 블럭킹소켓이다. 
    블럭킹 소켓으로 소켓함수( recv(), send(), accept() ) 호출시 조건이 완료될때까지 리턴안함.
    리턴조건 
             accept() : 클라접속했을때.
	     send() : 어플리케이션버퍼 -> 커널 송신버퍼에 데이터가 복사 완료시.
	     recv() : 커널 수신버퍼->어플리케이션버퍼로 복사 완료시.

    - 원쓰레드에서 블럭킹소켓으로 소켓함수 호출시 문제점은? 리턴을안해서 멈춘다.
    - SELECT 나 IOCP 등을 사용하는 이유는? 다른일을 동시에 처리할수있음


----------------------------------------------------------------------------------------------------------------
select는 많은 파일 디스크립터들을 한꺼번에 관찰하는 FD_SET 구조체를 사용하여 빠르고 간편하게 유저에게 파일 디스크립터의 상황을 알려준다. 
----------------------------------------------------------------------------------------------------------------

2. TCP 소켓서버/클라이언트 제작(2)
 위 프로젝트와 추가 및 변경상황.
 - (변경)소켓은 넌블럭킹 소켓으로 한다.
 - (추가)SELECT모델 사용.
 - 주쓰레드 : recv쓰레드 / data_check쓰레드 / send쓰레드  1개씩만 생성해서 운용!!
   ㄴrecv쓰레드(쓰레드1개로운용) 	 : 클라이언트 패킷받고, recv큐에 삽입 + SELECT 응용.
   ㄴdata_check쓰레드(쓰레드1개로운용)   : recv큐에있는 데이터를 pop하여 패킷시퀀스 태우기. 만약 클라이언트에 패킷보낼께 있다면 send큐에 삽입.
   ㄴsend쓰레드 			 : send큐에있는 데이터를 해당클라이언트에게 전송. + SELECT 응용.
 - 4개의 쓰레드를 나눈 이유를 생각하보고, 각 쓰레드내부 loop에 sleep을 어떤 비율로 줄지 생각해보기.
 